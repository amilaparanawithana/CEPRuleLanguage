package org.adroitlogic.ips.util.auth.filters;

import com.nimbusds.jwt.JWTClaimsSet;
import com.nimbusds.jwt.SignedJWT;
import net.minidev.json.JSONArray;
import org.adroitlogic.ips.services.userManagement.CachingService;
import org.adroitlogic.ips.util.auth.tokens.JWTAuthenticationToken;
import org.adroitlogic.ips.util.auth.tokens.JWTTokenManager;
import org.adroitlogic.ips.util.auth.util.AuthDataContainer;
import org.adroitlogic.ips.util.auth.util.JWTTokenEncrypt;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.shiro.SecurityUtils;
import org.apache.shiro.web.filter.authz.AuthorizationFilter;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;

import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.HashSet;
import java.util.Set;

/**
 * @author Chathura Widanage
 * @author Sajith Dilshan
 */
public class JWTAuthorizationFilter extends AuthorizationFilter {

    private static final Logger logger = LogManager.getLogger(JWTAuthorizationFilter.class);

    private static final String UNAUTHORIZED_MSG = "{\"msg\":\"Unauthorized\"}";
    private static final String CONTENT_TYPE = "application/json";

    private boolean filterOn = true;
    private String authUrl;

    @Autowired
    private JWTTokenManager jwtTokenManager;
    @Autowired
    private JWTTokenEncrypt jwtTokenEncrypt;
    @Autowired
    private CachingService cachingService;

    public JWTAuthorizationFilter(String authUrl) {
        this.authUrl = authUrl;
    }


    @Override
    protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) throws Exception {
        HttpServletRequest httpServletRequest = ((HttpServletRequest) servletRequest);
        String url = httpServletRequest.getRequestURI();
        if (logger.isTraceEnabled()) {
            logger.trace("Received a request for : {} from : {}", url, httpServletRequest.getRemoteUser());
        }
        //!IMPORTANT allow any Options request which are generated by angular.
        if (httpServletRequest.getMethod().equals("OPTIONS")) {
            return true;
        }

        if (url.contains(this.authUrl)) {//to auth url; allow access for any one
            return true;
        }

        final String authHeader = httpServletRequest.getHeader(HttpHeaders.AUTHORIZATION);

        if (authHeader != null) {
            SignedJWT signedJWT;
            boolean verified;

            try {
                String decryptedAuthHeader = jwtTokenEncrypt.decrypt(authHeader);
                signedJWT = jwtTokenManager.parse(decryptedAuthHeader);
                final JWTClaimsSet jwtClaimsSet = signedJWT.getJWTClaimsSet();

                final String username = jwtClaimsSet.getSubject();

                if (!authHeader.equals(cachingService.getValueFromCache(username))) {
                    logger.warn("Received an invalid JWT Token");
                    return false;
                }

                final long expirationTime = jwtClaimsSet.getExpirationTime().getTime();
                if (System.currentTimeMillis() >= expirationTime) {
                    logger.debug("Received an expired JWT token");
                    return false;
                }
                verified = jwtTokenManager.verify(signedJWT);

                Set<String> permissionSet = new HashSet<>();
                ((JSONArray) jwtClaimsSet.getClaim(JWTTokenManager.JWT_CLAIM_PERMISSIONS)).forEach(permission ->
                                permissionSet.add(permission.toString())
                );
                //adding permissions to the current session
                AuthDataContainer.setPermissions(permissionSet);

            } catch (Exception e) {
                logger.debug("Failed to parse or verify the JWT Token", e);
                return false;
            }

            if (verified) {
                logger.trace("Received a JWT token {}");
                SecurityUtils.getSubject().login(new JWTAuthenticationToken(signedJWT));
                return true;
            }
        }

        //temporary disabling jwt filter for all request(true) (return false will enable filter again)
        return !filterOn;
    }

    @Override
    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {

        response.setContentType(CONTENT_TYPE);
        ((HttpServletResponse) response).setStatus(200);
        response.getWriter().write(UNAUTHORIZED_MSG);
        response.getWriter().flush();
        response.getWriter().close();
        return false;
    }

    @SuppressWarnings("unused")
    public boolean isFilterOn() {
        return filterOn;
    }

    public void setFilterOn(boolean filterOn) {
        this.filterOn = filterOn;
    }
}
